/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 4.25.4
 * source: detection.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from 'google-protobuf';

export enum DetectionObject {
  Person = 0,
}
export class DetectImagesRequest extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          images?: Image[];
        },
  ) {
    super();
    pb_1.Message.initialize(
      this,
      Array.isArray(data) ? data : [],
      0,
      -1,
      [1],
      this.#one_of_decls,
    );
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('images' in data && data.images != undefined) {
        this.images = data.images;
      }
    }
  }
  get images() {
    return pb_1.Message.getRepeatedWrapperField(this, Image, 1) as Image[];
  }
  set images(value: Image[]) {
    pb_1.Message.setRepeatedWrapperField(this, 1, value);
  }
  static fromObject(data: {
    images?: ReturnType<typeof Image.prototype.toObject>[];
  }): DetectImagesRequest {
    const message = new DetectImagesRequest({});
    if (data.images != null) {
      message.images = data.images.map((item) => Image.fromObject(item));
    }
    return message;
  }
  toObject() {
    const data: {
      images?: ReturnType<typeof Image.prototype.toObject>[];
    } = {};
    if (this.images != null) {
      data.images = this.images.map((item: Image) => item.toObject());
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.images.length)
      writer.writeRepeatedMessage(1, this.images, (item: Image) =>
        item.serialize(writer),
      );
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(
    bytes: Uint8Array | pb_1.BinaryReader,
  ): DetectImagesRequest {
    const reader =
        bytes instanceof pb_1.BinaryReader
          ? bytes
          : new pb_1.BinaryReader(bytes),
      message = new DetectImagesRequest();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.images, () =>
            pb_1.Message.addToRepeatedWrapperField(
              message,
              1,
              Image.deserialize(reader),
              Image,
            ),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): DetectImagesRequest {
    return DetectImagesRequest.deserialize(bytes);
  }
}
export class DetectImagesResponse extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          detections?: ImageDetections[];
          error?: Error;
        },
  ) {
    super();
    pb_1.Message.initialize(
      this,
      Array.isArray(data) ? data : [],
      0,
      -1,
      [1],
      this.#one_of_decls,
    );
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('detections' in data && data.detections != undefined) {
        this.detections = data.detections;
      }
      if ('error' in data && data.error != undefined) {
        this.error = data.error;
      }
    }
  }
  get detections() {
    return pb_1.Message.getRepeatedWrapperField(
      this,
      ImageDetections,
      1,
    ) as ImageDetections[];
  }
  set detections(value: ImageDetections[]) {
    pb_1.Message.setRepeatedWrapperField(this, 1, value);
  }
  get error() {
    return pb_1.Message.getWrapperField(this, Error, 2) as Error;
  }
  set error(value: Error) {
    pb_1.Message.setWrapperField(this, 2, value);
  }
  get has_error() {
    return pb_1.Message.getField(this, 2) != null;
  }
  static fromObject(data: {
    detections?: ReturnType<typeof ImageDetections.prototype.toObject>[];
    error?: ReturnType<typeof Error.prototype.toObject>;
  }): DetectImagesResponse {
    const message = new DetectImagesResponse({});
    if (data.detections != null) {
      message.detections = data.detections.map((item) =>
        ImageDetections.fromObject(item),
      );
    }
    if (data.error != null) {
      message.error = Error.fromObject(data.error);
    }
    return message;
  }
  toObject() {
    const data: {
      detections?: ReturnType<typeof ImageDetections.prototype.toObject>[];
      error?: ReturnType<typeof Error.prototype.toObject>;
    } = {};
    if (this.detections != null) {
      data.detections = this.detections.map((item: ImageDetections) =>
        item.toObject(),
      );
    }
    if (this.error != null) {
      data.error = this.error.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.detections.length)
      writer.writeRepeatedMessage(1, this.detections, (item: ImageDetections) =>
        item.serialize(writer),
      );
    if (this.has_error)
      writer.writeMessage(2, this.error, () => this.error.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(
    bytes: Uint8Array | pb_1.BinaryReader,
  ): DetectImagesResponse {
    const reader =
        bytes instanceof pb_1.BinaryReader
          ? bytes
          : new pb_1.BinaryReader(bytes),
      message = new DetectImagesResponse();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          reader.readMessage(message.detections, () =>
            pb_1.Message.addToRepeatedWrapperField(
              message,
              1,
              ImageDetections.deserialize(reader),
              ImageDetections,
            ),
          );
          break;
        case 2:
          reader.readMessage(
            message.error,
            () => (message.error = Error.deserialize(reader)),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): DetectImagesResponse {
    return DetectImagesResponse.deserialize(bytes);
  }
}
export class Image extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          content?: Uint8Array;
        },
  ) {
    super();
    pb_1.Message.initialize(
      this,
      Array.isArray(data) ? data : [],
      0,
      -1,
      [],
      this.#one_of_decls,
    );
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('content' in data && data.content != undefined) {
        this.content = data.content;
      }
    }
  }
  get content() {
    return pb_1.Message.getFieldWithDefault(
      this,
      2,
      new Uint8Array(0),
    ) as Uint8Array;
  }
  set content(value: Uint8Array) {
    pb_1.Message.setField(this, 2, value);
  }
  static fromObject(data: { content?: Uint8Array }): Image {
    const message = new Image({});
    if (data.content != null) {
      message.content = data.content;
    }
    return message;
  }
  toObject() {
    const data: {
      content?: Uint8Array;
    } = {};
    if (this.content != null) {
      data.content = this.content;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.content.length) writer.writeBytes(2, this.content);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Image {
    const reader =
        bytes instanceof pb_1.BinaryReader
          ? bytes
          : new pb_1.BinaryReader(bytes),
      message = new Image();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 2:
          message.content = reader.readBytes();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): Image {
    return Image.deserialize(bytes);
  }
}
export class ImageDetections extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          detections?: Detection[];
        },
  ) {
    super();
    pb_1.Message.initialize(
      this,
      Array.isArray(data) ? data : [],
      0,
      -1,
      [2],
      this.#one_of_decls,
    );
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('detections' in data && data.detections != undefined) {
        this.detections = data.detections;
      }
    }
  }
  get detections() {
    return pb_1.Message.getRepeatedWrapperField(
      this,
      Detection,
      2,
    ) as Detection[];
  }
  set detections(value: Detection[]) {
    pb_1.Message.setRepeatedWrapperField(this, 2, value);
  }
  static fromObject(data: {
    detections?: ReturnType<typeof Detection.prototype.toObject>[];
  }): ImageDetections {
    const message = new ImageDetections({});
    if (data.detections != null) {
      message.detections = data.detections.map((item) =>
        Detection.fromObject(item),
      );
    }
    return message;
  }
  toObject() {
    const data: {
      detections?: ReturnType<typeof Detection.prototype.toObject>[];
    } = {};
    if (this.detections != null) {
      data.detections = this.detections.map((item: Detection) =>
        item.toObject(),
      );
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.detections.length)
      writer.writeRepeatedMessage(2, this.detections, (item: Detection) =>
        item.serialize(writer),
      );
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ImageDetections {
    const reader =
        bytes instanceof pb_1.BinaryReader
          ? bytes
          : new pb_1.BinaryReader(bytes),
      message = new ImageDetections();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 2:
          reader.readMessage(message.detections, () =>
            pb_1.Message.addToRepeatedWrapperField(
              message,
              2,
              Detection.deserialize(reader),
              Detection,
            ),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): ImageDetections {
    return ImageDetections.deserialize(bytes);
  }
}
export class Detection extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          object?: DetectionObject;
          score?: number;
          coords?: DetectionCoords;
        },
  ) {
    super();
    pb_1.Message.initialize(
      this,
      Array.isArray(data) ? data : [],
      0,
      -1,
      [],
      this.#one_of_decls,
    );
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('object' in data && data.object != undefined) {
        this.object = data.object;
      }
      if ('score' in data && data.score != undefined) {
        this.score = data.score;
      }
      if ('coords' in data && data.coords != undefined) {
        this.coords = data.coords;
      }
    }
  }
  get object() {
    return pb_1.Message.getFieldWithDefault(
      this,
      1,
      DetectionObject.Person,
    ) as DetectionObject;
  }
  set object(value: DetectionObject) {
    pb_1.Message.setField(this, 1, value);
  }
  get score() {
    return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
  }
  set score(value: number) {
    pb_1.Message.setField(this, 2, value);
  }
  get coords() {
    return pb_1.Message.getWrapperField(
      this,
      DetectionCoords,
      3,
    ) as DetectionCoords;
  }
  set coords(value: DetectionCoords) {
    pb_1.Message.setWrapperField(this, 3, value);
  }
  get has_coords() {
    return pb_1.Message.getField(this, 3) != null;
  }
  static fromObject(data: {
    object?: DetectionObject;
    score?: number;
    coords?: ReturnType<typeof DetectionCoords.prototype.toObject>;
  }): Detection {
    const message = new Detection({});
    if (data.object != null) {
      message.object = data.object;
    }
    if (data.score != null) {
      message.score = data.score;
    }
    if (data.coords != null) {
      message.coords = DetectionCoords.fromObject(data.coords);
    }
    return message;
  }
  toObject() {
    const data: {
      object?: DetectionObject;
      score?: number;
      coords?: ReturnType<typeof DetectionCoords.prototype.toObject>;
    } = {};
    if (this.object != null) {
      data.object = this.object;
    }
    if (this.score != null) {
      data.score = this.score;
    }
    if (this.coords != null) {
      data.coords = this.coords.toObject();
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.object != DetectionObject.Person) writer.writeEnum(1, this.object);
    if (this.score != 0) writer.writeFloat(2, this.score);
    if (this.has_coords)
      writer.writeMessage(3, this.coords, () => this.coords.serialize(writer));
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Detection {
    const reader =
        bytes instanceof pb_1.BinaryReader
          ? bytes
          : new pb_1.BinaryReader(bytes),
      message = new Detection();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.object = reader.readEnum();
          break;
        case 2:
          message.score = reader.readFloat();
          break;
        case 3:
          reader.readMessage(
            message.coords,
            () => (message.coords = DetectionCoords.deserialize(reader)),
          );
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): Detection {
    return Detection.deserialize(bytes);
  }
}
export class DetectionCoords extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          x?: number;
          y?: number;
          width?: number;
          height?: number;
        },
  ) {
    super();
    pb_1.Message.initialize(
      this,
      Array.isArray(data) ? data : [],
      0,
      -1,
      [],
      this.#one_of_decls,
    );
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('x' in data && data.x != undefined) {
        this.x = data.x;
      }
      if ('y' in data && data.y != undefined) {
        this.y = data.y;
      }
      if ('width' in data && data.width != undefined) {
        this.width = data.width;
      }
      if ('height' in data && data.height != undefined) {
        this.height = data.height;
      }
    }
  }
  get x() {
    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
  }
  set x(value: number) {
    pb_1.Message.setField(this, 1, value);
  }
  get y() {
    return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
  }
  set y(value: number) {
    pb_1.Message.setField(this, 2, value);
  }
  get width() {
    return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
  }
  set width(value: number) {
    pb_1.Message.setField(this, 3, value);
  }
  get height() {
    return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
  }
  set height(value: number) {
    pb_1.Message.setField(this, 4, value);
  }
  static fromObject(data: {
    x?: number;
    y?: number;
    width?: number;
    height?: number;
  }): DetectionCoords {
    const message = new DetectionCoords({});
    if (data.x != null) {
      message.x = data.x;
    }
    if (data.y != null) {
      message.y = data.y;
    }
    if (data.width != null) {
      message.width = data.width;
    }
    if (data.height != null) {
      message.height = data.height;
    }
    return message;
  }
  toObject() {
    const data: {
      x?: number;
      y?: number;
      width?: number;
      height?: number;
    } = {};
    if (this.x != null) {
      data.x = this.x;
    }
    if (this.y != null) {
      data.y = this.y;
    }
    if (this.width != null) {
      data.width = this.width;
    }
    if (this.height != null) {
      data.height = this.height;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.x != 0) writer.writeFloat(1, this.x);
    if (this.y != 0) writer.writeFloat(2, this.y);
    if (this.width != 0) writer.writeFloat(3, this.width);
    if (this.height != 0) writer.writeFloat(4, this.height);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): DetectionCoords {
    const reader =
        bytes instanceof pb_1.BinaryReader
          ? bytes
          : new pb_1.BinaryReader(bytes),
      message = new DetectionCoords();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.x = reader.readFloat();
          break;
        case 2:
          message.y = reader.readFloat();
          break;
        case 3:
          message.width = reader.readFloat();
          break;
        case 4:
          message.height = reader.readFloat();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): DetectionCoords {
    return DetectionCoords.deserialize(bytes);
  }
}
export class Error extends pb_1.Message {
  #one_of_decls: number[][] = [];
  constructor(
    data?:
      | any[]
      | {
          code?: number;
          message?: string;
        },
  ) {
    super();
    pb_1.Message.initialize(
      this,
      Array.isArray(data) ? data : [],
      0,
      -1,
      [],
      this.#one_of_decls,
    );
    if (!Array.isArray(data) && typeof data == 'object') {
      if ('code' in data && data.code != undefined) {
        this.code = data.code;
      }
      if ('message' in data && data.message != undefined) {
        this.message = data.message;
      }
    }
  }
  get code() {
    return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
  }
  set code(value: number) {
    pb_1.Message.setField(this, 1, value);
  }
  get message() {
    return pb_1.Message.getFieldWithDefault(this, 2, '') as string;
  }
  set message(value: string) {
    pb_1.Message.setField(this, 2, value);
  }
  static fromObject(data: { code?: number; message?: string }): Error {
    const message = new Error({});
    if (data.code != null) {
      message.code = data.code;
    }
    if (data.message != null) {
      message.message = data.message;
    }
    return message;
  }
  toObject() {
    const data: {
      code?: number;
      message?: string;
    } = {};
    if (this.code != null) {
      data.code = this.code;
    }
    if (this.message != null) {
      data.message = this.message;
    }
    return data;
  }
  serialize(): Uint8Array;
  serialize(w: pb_1.BinaryWriter): void;
  serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
    const writer = w || new pb_1.BinaryWriter();
    if (this.code != 0) writer.writeInt32(1, this.code);
    if (this.message.length) writer.writeString(2, this.message);
    if (!w) return writer.getResultBuffer();
  }
  static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Error {
    const reader =
        bytes instanceof pb_1.BinaryReader
          ? bytes
          : new pb_1.BinaryReader(bytes),
      message = new Error();
    while (reader.nextField()) {
      if (reader.isEndGroup()) break;
      switch (reader.getFieldNumber()) {
        case 1:
          message.code = reader.readInt32();
          break;
        case 2:
          message.message = reader.readString();
          break;
        default:
          reader.skipField();
      }
    }
    return message;
  }
  serializeBinary(): Uint8Array {
    return this.serialize();
  }
  static deserializeBinary(bytes: Uint8Array): Error {
    return Error.deserialize(bytes);
  }
}
